#!/usr/bin/env python3
import json
import subprocess
import csv
import io
import sys
import os
from pathlib import Path
import tempfile
from typing import Optional
from urllib.request import urlretrieve

API_KEY = os.getenv("ALCHEMY_API_KEY")
if API_KEY is None:
    print("Please set the ALCHEMY_API_KEY environment variable.")
    sys.exit(1)

ZERO_ADDRESS = f"0x{'0'*40}"
ZERO_BYTES32 = f"0x{'0'*64}"
PROXY_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"

NETWORKS = {
    "mainnet": {
        "display_name": "Celo Mainnet",
        "files": {
            "rollup.json": "https://storage.googleapis.com/cel2-rollup-files/celo/rollup.json",
            "config.json": "https://storage.googleapis.com/cel2-rollup-files/celo/config.json",
            "deployment-l1.json": "https://storage.googleapis.com/cel2-rollup-files/celo/deployment-l1.json",
            "contracts-l1.json": "https://storage.googleapis.com/cel2-rollup-files/celo/contracts-l1.json",
        },
        "l2_rpc": "https://forno.celo.org",
        "l1_rpc": f"https://eth-mainnet.g.alchemy.com/v2/{API_KEY}",
        "l1_explorer": "https://eth.blockscout.com",
        "l2_explorer": "https://celo.blockscout.com",
    },
    "celo-sepolia": {
        "display_name": "Celo Sepolia Testnet",
        "files": {
            "rollup.json": "https://storage.googleapis.com/cel2-rollup-files/celo-sepolia/rollup.json",
            "deployment-l1.json": "https://storage.googleapis.com/cel2-rollup-files/celo-sepolia/deployment-l1.json",
            "contracts-l1.json": "https://storage.googleapis.com/cel2-rollup-files/celo-sepolia/contracts-l1.json",
        },
        "l2_rpc": "https://forno.celo-sepolia.celo-testnet.org",
        "l1_rpc": f"https://eth-sepolia.g.alchemy.com/v2/{API_KEY}",
        "l1_explorer": "https://eth-sepolia.blockscout.com",
        "l2_explorer": "https://celo-sepolia.blockscout.com",
    },
}

PAGE_HEADER_CORE_CONTRACTS = """
---
title: Core Contracts
id: core-contracts
---

[comment]: <> (DO NOT EDIT THIS FILE MANUALLY)
[comment]: <> (Autogenerated by `scripts/update_contracts.py`)

Core contract addresses for the Celo networks.
""".strip()

PAGE_HEADER_L1_CONTRACTS = """
---
title: L1 Contracts
id: l1-contracts
---

[comment]: <> (DO NOT EDIT THIS FILE MANUALLY)
[comment]: <> (Autogenerated by `scripts/update_contracts.py`)

L1 contract addresses for the Celo networks.
""".strip()

PAGE_HEADER_TOKEN_CONTRACTS = """
---
title: Token Contracts
id: token-contracts
---

[comment]: <> (DO NOT EDIT THIS FILE MANUALLY)
[comment]: <> (Autogenerated by `scripts/update_contracts.py`)

Token addresses for Celo assets on Mainnet and the Celo Sepolia Testnet.

<Tip>
You can also query the list of listed fee currencies with the Celo CLI:

```sh
celocli network:whitelist
```
</Tip>

---
""".strip()


def check_celocli_exists() -> bool:
    """Check if the celocli binary exists in PATH using only stdlib."""
    paths = os.environ.get("PATH", "").split(os.pathsep)
    exts = [""] + (
        os.environ.get("PATHEXT", "").split(os.pathsep) if os.name == "nt" else []
    )
    for path in paths:
        for ext in exts:
            full_path = os.path.join(path, "celocli" + ext)
            if os.path.isfile(full_path) and os.access(full_path, os.X_OK):
                return True
    return False


def fetch_celo_cli_csv(network: str, command: str) -> str:
    """Run celocli and return its CSV output."""
    try:
        result = subprocess.run(
            [
                "celocli",
                command,
                "--node",
                NETWORKS[network]["l2_rpc"],
                "--csv",
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        sys.exit(f"Error: celocli failed:\n{e.stderr}")
    except FileNotFoundError:
        sys.exit("Error: celocli binary not found in PATH.")


def csv_to_markdown(csv_text: str, network: str) -> str:
    """Convert CSV text to Markdown table with proxy links."""
    reader = csv.DictReader(io.StringIO(csv_text))
    lines = ["| Contract | Proxy |", "| -------- | ------ |"]
    for row in reader:
        contract = row.get("Contract", "").strip()
        proxy = row.get("Proxy", "").strip()
        if proxy:
            link = f"[`{proxy}`]({NETWORKS[network]['l2_explorer']}/address/{proxy})"
            lines.append(f"| {contract} | {link} |")
    return "\n".join(lines)


def token_csv_to_markdown(csv_text: str, network: str) -> str:
    reader = csv.DictReader(io.StringIO(csv_text))
    sorted_rows = sorted(reader, key=lambda row: row["Symbol"].lower())
    lines = ["| Token | Symbol | Token Address |", "| ----- | ------ | ------------- |"]
    for row in sorted_rows:
        contract = row.get("Name", "").strip()
        symbol = row.get("Symbol", "").strip()
        address = row.get("Token Address", "").strip()
        if address:
            link = (
                f"[`{address}`]({NETWORKS[network]['l2_explorer']}/address/{address})"
            )
            lines.append(f"| {contract} | {symbol} | {link} |")
    return "\n".join(lines)

def get_l1_contracts(network: str) -> str:
    net = NETWORKS[network]
    base_url = net["l1_explorer"]

    lines = ["| Contract | Address |", "| -------- | ------- |"]
    with tempfile.TemporaryDirectory() as tmpdir:
        tmppath = Path(tmpdir)
        for filename, url in net["files"].items():
            urlretrieve(url, tmppath / filename)

        l1 = json.load(open(tmppath / "contracts-l1.json"))

        for contract, address in l1.items():
            if address == ZERO_ADDRESS:
                continue

            print("L1:", contract)
            lines.append(f"| {contract} | [`{address}`]({base_url}/address/{address}) |")

            if contract.endswith("Proxy"):
                impl = retrieve_impl(contract, address, net)
                if impl is None:
                    print("  No implementation found!")
                    continue

                print("  Impl:", impl)
                lines.append(f"| {contract.replace('Proxy', 'Impl')} | [`{impl}`]({base_url}/address/{impl}) |")

    return "\n".join(lines)

def bytes32_to_address(b: str) -> str:
    if len(b) != 66 or not b.startswith("0x"):
        raise ValueError(f"Invalid bytes32: {b}")
    return f"0x{b[26:]}"

def resolve_delegate_proxy(contract, address, net) -> Optional[str]:
    # compute storage slot for address manager
    manager_slot = subprocess.check_output(
        [
            "cast",
            "index",
            "address",
            address,
            "1",
        ],
        encoding="utf-8",
    ).strip()

    # load address manager address from storage
    manager_address = subprocess.check_output(
        [
            "cast",
            "storage",
            "-r",
            net["l1_rpc"],
            address,
            manager_slot,
        ],
        encoding="utf-8",
    ).strip()

    # if no address manager, return
    if manager_address == ZERO_BYTES32:
        return None

    manager_address = bytes32_to_address(manager_address)

    # retrieve implementation address from address manager
    impl = subprocess.check_output(
        [
            "cast",
            "call",
            "-r",
            net["l1_rpc"],
            manager_address,
            "getAddress(string)(address)",
            f'OVM_{contract.replace("Proxy", "")}',
        ],
        encoding="utf-8",
    ).strip()

    return impl

def retrieve_impl(contract, address, net) -> tuple[bool, str]:
    impl = subprocess.check_output(
        [
            "cast",
            "storage",
            "-r",
            net["l1_rpc"],
            address,
            PROXY_SLOT,
        ],
        encoding="utf-8",
    ).strip()

    if impl == ZERO_BYTES32:
        return resolve_delegate_proxy(contract, address, net)

    impl = bytes32_to_address(impl)

    return impl

def main():
    if not check_celocli_exists():
        sys.exit(
            "Error: 'celocli' binary not found. Please install it first: npm install -g @celo/celocli"
        )

    print("Fetching core contract data from celocli...")
    with Path("tooling/contracts/core-contracts.mdx").open("w") as f:
        f.write(PAGE_HEADER_CORE_CONTRACTS)

        for network, data in NETWORKS.items():
            print(f"> Fetching contract data from celocli for {network}...")

            csv_output = fetch_celo_cli_csv(network, "network:contracts")
            markdown = csv_to_markdown(csv_output, network)

            f.write(f"\n\n## {data['display_name']}\n\n")
            f.write(markdown)

    print("Fetching token contract data from celocli...")
    with Path("tooling/contracts/token-contracts.mdx").open("w") as f:
        f.write(PAGE_HEADER_TOKEN_CONTRACTS)

        for network, data in NETWORKS.items():
            print(
                f"> Fetching fee currency contract data from celocli for {network}..."
            )

            csv_output = fetch_celo_cli_csv(network, "network:whitelist")
            markdown = token_csv_to_markdown(csv_output, network)

            f.write(f"\n\n## {data['display_name']}\n\n")
            f.write(markdown)

    print("Fetching L1 contract data...")
    with Path("tooling/contracts/l1-contracts.mdx").open("w") as f:
        f.write(PAGE_HEADER_L1_CONTRACTS)

        for network, data in NETWORKS.items():
            print(
                f"> Fetching l1 contract data for {network}..."
            )

            markdown = get_l1_contracts(network)

            f.write(f"\n\n## {data['display_name']}\n\n")
            f.write(markdown)


if __name__ == "__main__":
    main()
